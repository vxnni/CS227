package hw3;
import java.util.ArrayList;
import java.util.Random;

import api.Direction;
import api.ShiftDescriptor;
import api.TileInfo;
import ui.ConsoleUI;

import static api.Direction.*;
import java.util.Arrays;
/**
 * This class contains the state and logic for an implementation of a
 * video game we call AlphabetSoup.  The basic underlying state is an n by n 
 * grid of tiles, represented by integer values.  A zero in a cell is considered 
 * to be "empty".  To play the game, a client calls the method <code>shift()</code>, 
 * selecting one of the four directions (LEFT, RIGHT, UP, DOWN). Each row or 
 * column is then shifted according to the rules encapsulated in the
 * associated <code>AlphabetUtil</code> object. The move is completed by
 * calling <code>setNewTile</code>, which makes a new tile appear in the grid
 * in preparation for the next move.
 * <p>
 * The game uses an instance of java.util.Random to generate new tile values
 * and to select the location for a new tile to appear.  The new values
 * are generated by the associated <code>AlphabetUtil</code>'s 
 * <code>randomNewTileValue</code> method, and the new positions are
 * generated in the <code>setNewTile</code> method of this class. 
 * <p>
 * The score in the game is the sum, over all cells, of the individual scores
 * returned by the <code>AlphabetUtil</code>'s <code>getScoreForOneTile()</code> 
 * method.
 * @author Vincent Wang
 */
public class AlphabetSoup
{	//Declares the grid used in the game
	private int[][] grid;
	//Constructor for the other class
	AlphabetUtil util = new AlphabetUtil();
	//Score for the game
	private int score = 0;
	//Direction of which the user plays
	private Direction direction = null;
	//Random generator used for tiles
	Random rando = new Random();

  /**
   * Constructs a game with a grid of the given size, using a default
   * random number generator. The initial grid is produced by the 
   * <code>createNewGrid</code> method of the given 
   * <code>AlphabetUtil</code> object.  
   * @param givenSize
   *   size of the grid for this game
   * @param givenConfig
   *   given instance of GameUtil   
   */
  public AlphabetSoup(int givenSize, AlphabetUtil givenConfig)
  {
    grid = new int[givenSize][givenSize];
    Random rando = new Random();
    setCell(rando.nextInt(5), rando.nextInt(5), givenConfig.randomNewTileValue(rando));
    setCell(rando.nextInt(5), rando.nextInt(5), givenConfig.randomNewTileValue(rando));
    
  }
  
  /**
   * Constructs a game with a grid of the given size, using the given
   * instance of <code>Random</code> for the random number generator.
   * The initial grid is produced by the <code>createNewGrid</code> method 
   * of the given <code>AlphabetUtil</code> object.  
   * @param givenSize
   *   size of the grid for this game
   * @param givenConfig
   *   given instance of AlphabetUtil
   * @param givenRandom
   *   given instance of Random   
   */
  public AlphabetSoup(int givenSize, AlphabetUtil givenConfig, Random givenRandom)
  {
	
    grid = new int[givenSize][givenSize];
    setCell(givenRandom.nextInt(givenSize), givenRandom.nextInt(givenSize), givenConfig.randomNewTileValue(givenRandom));
    setCell(givenRandom.nextInt(givenSize), givenRandom.nextInt(givenSize), givenConfig.randomNewTileValue(givenRandom));
  }
  
  /**
   * Returns the value in the cell at the given row and column.
   * @param row
   *   given row
   * @param col
   *   given column
   * @return
   *   value in the cell at the given row and column
   */
  public int getCell(int row, int col)
  {
    return grid[row][col];
  }
  
  /**
   * Sets the value of the cell at the given row and column.
   * <em>NOTE: This method should not be used by clients outside
   * of a testing environment.</em>
   * @param row
   *   given row
   * @param col
   *   given col
   * @param value
   *   value to be set
   */
  public void setCell(int row, int col, int value)
  {
    grid[row][col] = value;
  }
  
  /**
   * Returns the size of this game's grid.
   * @return
   *   size of the grid
   */
  public int getSize()
  {
    return grid.length;
  }
  
  /**
   * Returns the current score.
   * @return
   *   score for this game
   */
  public int getScore()
  {
	return score;
  }
  
  /**
   * Returns the direction from the most recent call to <code>shift()</code>
   * when a corresponding call to <code>setNewTile()</code> has not yet been 
   * made. Otherwise, the method returns null.
   * @return
   *   direction of current pending shift
   */
  
  //direction
  public Direction getLastDirection()
  {
    return direction;
  }
  
  /**
   * Copy a row or column from the grid into a new one-dimensional array.  
   * There are four possible actions depending on the given direction:
   * <ul>
   *   <li>LEFT - the row indicated by the index <code>rowOrColumn</code> is
   *   copied into the new array from left to right
   *   <li>RIGHT - the row indicated by the index <code>rowOrColumn</code> is
   *   copied into the new array in reverse (from right to left)
   *   <li>UP - the column indicated by the index <code>rowOrColumn</code> is
   *   copied into the new array from top to bottom
   *   <li>DOWN - the row indicated by the index <code>rowOrColumn</code> is
   *   copied into the new array in reverse (from bottom to top)
   * </ul>
   * @param rowOrColumn
   *   index of the row or column
   * @param dir
   *   direction from which to begin copying
   * @return
   *   array containing the row or column
   */
  
 
  public int[] getRowColumn(int rowOrColumn, Direction dir)
  {
    int[] newArr;
    int startIndex = 0;
    newArr = new int[grid[rowOrColumn].length];
    
    if(dir == Direction.LEFT) {
    	for(int j = 0; j < grid.length; j++) {
    			newArr[j] = grid[rowOrColumn][j];
    		}
    }else if(dir == Direction.RIGHT) {
    		for(int j = grid.length - 1; j >= 0; j--) {
    			newArr[startIndex] = grid[rowOrColumn][j];
    			startIndex++;
    		}
    }else if (dir == Direction.UP) {
    		for(int j = 0; j < grid.length; j++) {
    			newArr[j] = grid[j][rowOrColumn];
    	}
    }else if(dir == Direction.DOWN){
    		for(int j = grid.length - 1; j >= 0; j--) {
    			newArr[startIndex] = grid[j][rowOrColumn];
    			startIndex++;
    		}
    		
    }
    
    return newArr;
  }
    
  /**
   * Updates the grid by copying the given one-dimensional array into
   * a row or column of the grid.
   * There are four possible actions depending on the given direction:
   * <ul>
   *   <li>LEFT - the given array is copied into the the row indicated by the 
   *   index <code>rowOrColumn</code> from left to right
   *   <li>RIGHT - the given array is copied into the the row indicated by the 
   *   index <code>rowOrColumn</code> in reverse (from right to left)
   *   <li>UP - the given array is copied into the column indicated by the 
   *   index <code>rowOrColumn</code> from top to bottom
   *   <li>DOWN - the given array is copied into the column indicated by the 
   *   index <code>rowOrColumn</code> in reverse (from bottom to top)
   * </ul>
   * @param arr
   *   the array from which to copy
   * @param rowOrColumn
   *   index of the row or column
   * @param dir
   *   direction from which to begin copying
   */
  public void setRowColumn(int[] arr, int rowOrColumn, Direction dir)
  {
	if(dir == Direction.LEFT) {
		for(int i = rowOrColumn; i < rowOrColumn + 1; i++) {
			for(int j = 0; j < arr.length; j++) {
				grid[i][j] = arr[j];
			}
		}
	}else if(dir == Direction.RIGHT) {
		for(int i = rowOrColumn; i < rowOrColumn + 1; i++) {
			for(int j = arr.length - 1; j > 0; j--) {
				grid[i][j] = arr[grid.length - j - 1];
			}
		}
	}else if(dir == Direction.UP) {
		for(int i = 0; i < grid.length; i++) {
    		for(int j = rowOrColumn; j < rowOrColumn + 1; j++) {
    			grid[i][j] = arr[i];
    			
    		}
  
		}
	}
	else if(dir == Direction.DOWN){
		for(int i = grid.length - 1; i >= 0; i--) {
    		for(int j = rowOrColumn; j < rowOrColumn + 1; j++) {
    			grid[i][j] = arr[grid.length - i - 1];
    			

    		}
  
    	}
	}
  }

  /**
   * Plays one step of the game by shifting the grid in the given direction.
   * Returns a list of <code>ShiftDescriptor</code> objects describing all 
   * moves performed.  All <code>ShiftDescriptor</code> 
   * objects must include a valid value for <code>getRowOrColumn()</code> and 
   * <code>getDirection()</code>.  If no cells are actually moved, the method returns
   * an empty list.
   * <p>
   * The shift of an individual row or column is performed by the 
   * method <code>shift()</code> of the associated <code>AlphabetUtil</code>
   * instance.  
   * <p>
   * This method does not update the score (that occurs in <code>setNewTile()</code>).
   * 
   * @param dir
   *   direction in which to shift the grid
   * @return
   *   list of moved or merged tiles
   */
  public ArrayList<ShiftDescriptor> shift(Direction dir)
  {
    direction = dir;
    int [] newArr = new int[grid[0].length];
    int zeroIndex = findIndex(newArr, 0);
	boolean canMerge = false;
	int temp;
	
	temp = newArr[0];
	
    ArrayList<ShiftDescriptor> shift = new ArrayList<ShiftDescriptor>();
	
    if(dir != null) {
    	for(int j = 0; j < grid.length; j++) {
    		newArr = getRowColumn(j, dir);
    		System.out.println(Arrays.toString(newArr));
    		
    		for(int i = 0; i < newArr.length - 1; i++) 
    		{ 
    			if(newArr[i] == 0) {
    				zeroIndex = i;
    				
    			}
    			if(newArr[i] == newArr[i + 1]) {
    				canMerge = true;
    			
    			}
    			if(canMerge && i > zeroIndex) {
    				shift.add(new ShiftDescriptor(newArr[i + 1], newArr[i], findMergedValue(newArr[i], newArr[i+1])));
    				newArr[i] = findMergedValue(newArr[i], newArr[i+1]);
    				newArr[i+1] = 0;
    				
    			}else {
    				shift.add(new ShiftDescriptor(newArr[i + 1], newArr[i]));
    				newArr[i]=newArr[i+1];
    				
    			}
    		}
    		newArr[newArr.length - 1] = 0;
        	if(temp != 0) {
        		newArr[0] =temp; 
        	}
        	for(int k = 0; k < grid.length; k++) {
        		setRowColumn(newArr, k, dir);
        	}
    	}
    }
    	return shift;
    }
    

  
  private static int findIndex(int arr[], int t) 
  { 

 
      if (arr == null) { 
          return -1; 
      } 

      int length = arr.length; 
      int i = 0; 
     

      while (i < length) { 
 
          if (arr[i] == t) { 
              return i; 
          } 
          else { 
              i++; 
          } 
      } 
      return -1; 
  }
  
  private int findMergedValue(int a, int b)
  {
    if((a == b) && (a != 0)) {
    	return a + 1;
    }else {
    	return 0;
    }
  }
  
  /**
   * Generates a new tile and places its value in the grid, provided that
   * there was a previous call to  <code>shift()</code> without a 
   * corresponding call to <code>setNewTile</code> (in other words, 
   * when <code>getLastDirection()</code> returns a non-null value). 
   * In all other cases, this method does nothing and returns null.
   * <p>
   * The tile's value is determined by the associated
   * <code>AlphabetUtil</code>'s <code>randomNewTileValue()</code> method.
   * The tile's position is randomly selected from the empty cells
   * on the side of the grid opposite the previous move's direction.
   * <p>
   * This method updates the total score, and the score includes the newly 
   * generated tile.
   * 
   * @return
   *   TileInfo object containing the new tile's position and value, or null
   *   if no new tile is added to the grid
   */
  
  public TileInfo setNewTile()
  {
	int randomRow;
	int randomCol;
	if(getLastDirection() != null) {
    	if(getLastDirection() == Direction.LEFT) {
    		randomRow = rando.nextInt(2);
    		randomCol = grid.length - 1;
    		grid[randomRow][randomCol] = rando.nextInt(2) + 1;
    		score += grid[randomRow][randomCol];
    	}else if(getLastDirection() == Direction.RIGHT) {
    		randomRow = rando.nextInt(2);
    		randomCol = 0;
    		grid[randomRow][randomCol] = rando.nextInt(2) + 1;
    		score += grid[randomRow][randomCol];
    	}else if(getLastDirection() == Direction.UP) {
    		randomRow = grid.length - 1;
    		randomCol = rando.nextInt(2);
    		grid[randomRow][randomCol] = rando.nextInt(2) + 1;
    		score += grid[randomRow][randomCol];
    	}else {
    		randomRow = 0;
    		randomCol = rando.nextInt(2);
    		grid[randomRow][randomCol] = rando.nextInt(2) + 1;
    		score += grid[randomRow][randomCol];
    		
    	}
 
    
    	return new TileInfo(randomRow, randomCol, rando.nextInt(2) + 1);
	}
    return null;
  }
  
  public static void main(String args[]) {
	 // AlphabetSoup(int givenSize, AlphabetUtil givenConfig, Random givenRandom)
	 
	  
	  AlphabetSoup g = new AlphabetSoup(5, new AlphabetUtil(), new Random(42));
	  int[] arr = {1, 2, 3, 4, 5};
	  System.out.println("Before:");
	  ConsoleUI.printGrid(g);
	  g.setRowColumn(arr, 2, Direction.DOWN);
	  System.out.println("After:");
	  ConsoleUI.printGrid(g);
	  
	  int[] result = g.getRowColumn(2, Direction.DOWN);
	  System.out.println(Arrays.toString(result));
	  System.out.println("Expected [1, 2, 3, 4, 5]");
	  
	  g = new AlphabetSoup(4, new AlphabetUtil(), new Random(42));
	  int[][] testGrid1 =
	  {
	  { 0, 2, 3, 1 },
	  { 0, 1, 3, 2 },
	  { 0, 2, 3, 0 },
	  { 0, 1, 2, 0 }
	  };
	  for (int row = 0; row < testGrid1.length; row += 1)
	  {
		  for (int col = 0; col < testGrid1[0].length; col += 1)
		  {
		  g.setCell(row, col, testGrid1[row][col]);
		  }
	  }
	  System.out.println("Before: ");
	  ConsoleUI.printGrid(g);
	  g.shift(Direction.DOWN);
	  System.out.println("After: ");
	  ConsoleUI.printGrid(g);
	  
	  System.out.println("Expected: " + " After:\r\n"
	  		+ "---------------\r\n"
	  		+ "- b - -\r\n"
	  		+ "- a c a\r\n"
	  		+ "- b d b\r\n"
	  		+ "- a b -\r\n"
	  		+ "---------------");
	  
	  System.out.println(g.getLastDirection());
	  System.out.println("Expected DOWN");

  }
}
  










